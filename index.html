<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>九九合わせ Pro - Online</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --casino-green: radial-gradient(circle, #1a4d2e 0%, #0d2a1a 100%);
            --gold: #d4af37;
            --glass: rgba(255, 255, 255, 0.05);
            --card-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Noto Sans JP', sans-serif;
            background: #000;
            /* Letterbox background */
            color: white;
            min-height: 100vh;
            overflow: hidden;
            /* Prevent scrollbars from full viewport */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #game-container {
            display: flex;
            aspect-ratio: 4 / 3;
            width: min(100vw, 100vh * 4 / 3);
            height: min(100vh, 100vw * 3 / 4);
            background: var(--casino-green);
            /* Move actual game bg here */
            padding: 15px;
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            border: 1px solid #333;
        }

        #side-panel {
            width: 280px;
            min-width: 250px;
            background: var(--glass);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            margin-right: 15px;
            padding: 12px;
        }

        .info-bar {
            margin-bottom: 12px;
        }

        #status-message {
            font-size: 1rem;
            font-weight: bold;
            color: var(--gold);
            margin-bottom: 5px;
        }

        #start-btn {
            width: 100%;
            padding: 12px;
            background: var(--gold);
            color: #000;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 10px;
            font-size: 1rem;
            transition: all 0.2s;
        }

        #start-btn:hover {
            background: #f7e7ce;
            transform: scale(1.02);
        }

        #start-btn:disabled {
            background: #555;
            color: #888;
            cursor: not-allowed;
        }

        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            font-size: 0.85rem;
            line-height: 1.5;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        #game-board {
            flex: 1;
            position: relative;
            display: grid;
            grid-template-areas:
                "round-info      score-cpu2     north-hand     .              ."
                "score-cpu1      north-discard  north-discard  north-discard  score-cpu3"
                "west-hand       west-discard   center         east-discard   east-hand"
                ".               south-discard  south-discard  south-discard  ."
                ".               score-player   south-hand     .              .";
            grid-template-columns: auto 1fr auto 1fr auto;
            grid-template-rows: auto auto 1fr auto auto;
            gap: 5px;
            padding: 10px;
            align-items: center;
            justify-items: center;
        }

        #round-info {
            grid-area: round-info;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--gold);
            white-space: nowrap;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--gold);
        }

        .score-tag {
            position: absolute;
            background: var(--gold);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        /* スコアバッジの位置調整 */
        #score-cpu2 {
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* North */
        #score-player {
            top: -15px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* South */
        #score-cpu1 {
            right: -15px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* West */
        #score-cpu3 {
            left: -15px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* East */

        /* 捨て札エリアをrelativeにしてスコアの基準点にする */
        .discard-area {
            position: relative !important;
            overflow: visible !important;
        }

        .player-slot {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .north-hand {
            grid-area: north-hand;
        }

        .north-discard {
            grid-area: north-discard;
        }

        .south-hand {
            grid-area: south-hand;
        }

        .south-discard {
            grid-area: south-discard;
        }

        .west-hand {
            grid-area: west-hand;
        }

        .west-discard {
            grid-area: west-discard;
        }

        .east-hand {
            grid-area: east-hand;
        }

        .east-discard {
            grid-area: east-discard;
        }

        #center-area {
            grid-area: center;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .card {
            width: 70px;
            height: 98px;
            background: white;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a1a;
            font-weight: normal;
            font-size: 3rem;
            font-family: "UnifrakturMaguntia", serif;
            letter-spacing: 2px;
            box-shadow: var(--card-shadow);
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            cursor: pointer;
            user-select: none;
            border: 1px solid #ccc;
        }

        .card.back {
            background: #0d2a1a;
            border: 2px solid var(--gold);
            color: transparent;
            background-image: radial-gradient(var(--gold) 1px, transparent 1px);
            background-size: 5px 5px;
        }

        .card.mini {
            width: 50px;
            height: 70px;
            font-size: 1rem;
        }

        .card.rotated {
            width: 50px;
            height: 70px;
            font-size: 1rem;
            transform: rotate(90deg);
        }

        .card.rotated-east {
            width: 50px;
            height: 70px;
            font-size: 1rem;
            transform: rotate(-90deg);
        }

        .hand-area {
            display: flex;
            gap: 4px;
            padding: 4px;
            border-radius: 6px;
            justify-content: center;
            /* Ensure consistent spacing alignment */
        }

        .hand-area.vertical {
            flex-direction: column;
            gap: 4px;
            /* Unify gap with horizontal (was 3px) */
        }

        #player-hand.hand-area {
            background: rgba(0, 0, 0, 0.2);
            min-height: 100px;
            min-width: 280px;
            justify-content: center;
        }

        #player-hand .card:hover {
            transform: translateY(-12px) scale(1.1);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        .meta {
            font-size: 0.75rem;
            color: var(--gold);
            margin: 3px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 8px;
            border: 1px solid var(--gold);
        }

        .discard-area {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            padding: 4px;
            min-height: 55px;
            max-height: 80px;
            min-width: 150px;
            max-width: 250px;
            min-width: 150px;
            max-width: 250px;
            /* border: 1px dashed rgba(255, 255, 255, 0.2); Removed per user request */
            border: none;
            border-radius: 5px;
            /* background: rgba(255, 255, 255, 0.02); */
            overflow-y: auto;
            align-content: flex-start;
        }

        .discard-area.vertical {
            flex-direction: row;
            flex-wrap: wrap;
            max-width: 120px;
            min-width: 120px;
            max-height: 250px;
            min-height: 60px;
        }

        .discard-card {
            width: 36px;
            height: 50px;
            background: white;
            border-radius: 4px;
            display: flex;
            align-items: center;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #1a1a1a;
            font-weight: normal;
            font-size: 1.5rem;
            /* Increased size for readability with new font */
            font-family: "UnifrakturMaguntia", serif;
            letter-spacing: 1px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            border: 1px solid #aaa;
        }

        .discard-card.rotated {
            width: 50px;
            height: 36px;
            /* transform: rotate(90deg); Removed to fix layout overflow */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Rotate the text inside if needed, or leave it upright. For now upright. */

        #deck-count {
            font-size: 0.85rem;
            font-weight: bold;
            color: var(--gold);
            margin-top: 5px;
        }

        #reveal-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: auto;
            height: auto;
            padding: 30px;
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid var(--gold);
            border-radius: 15px;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            box-shadow: 0 0 30px rgba(212, 175, 55, 0.5);
        }

        .reveal-title {
            font-size: 1.8rem;
            color: var(--gold);
            margin-bottom: 20px;
        }

        .reveal-cards {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .reveal-cards .card {
            width: 80px;
            height: 112px;
            font-size: 1.5rem;
        }

        #close-reveal {
            margin-top: 30px;
            padding: 10px 40px;
            background: var(--gold);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 1rem;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .animate-draw {
            animation: fadeIn 0.3s ease-out;
        }

        .animate-discard {
            animation: slideIn 0.2s ease-out;
        }

        @keyframes glowGold {
            0% {
                box-shadow: 0 0 5px var(--gold);
            }

            50% {
                box-shadow: 0 0 20px var(--gold), 0 0 10px white;
            }

            100% {
                box-shadow: 0 0 5px var(--gold);
            }
        }

        @keyframes glowRed {
            0% {
                box-shadow: 0 0 5px red;
            }

            50% {
                box-shadow: 0 0 20px red, 0 0 10px white;
                border-color: red;
            }

            100% {
                box-shadow: 0 0 5px red;
            }
        }

        .winner-card {
            animation: glowGold 1.5s infinite;
            border: 2px solid var(--gold) !important;
            z-index: 100;
        }

        .ron-card {
            animation: glowRed 1s infinite;
            border: 2px solid red !important;
            z-index: 100;
        }

        /* Patch CSS */
        #round-info {
            grid-area: round-info;
            font-size: 1.2rem;
            font-weight: bold;
            color: var(--gold);
            white-space: nowrap;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            border: 1px solid var(--gold);
        }

        .score-tag {
            background: var(--gold);
            color: #000;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 20;
            pointer-events: none;
            min-width: 80px;
            text-align: center;
        }

        #score-cpu2 {
            grid-area: score-cpu2;
            align-self: center;
            justify-self: end;
            margin: 0 10px 0 0;
        }

        #score-player {
            grid-area: score-player;
            align-self: center;
            justify-self: end;
            margin: 0 10px 0 0;
        }

        #score-cpu1 {
            grid-area: score-cpu1;
            align-self: end;
            justify-self: center;
            margin: 0 0 5px 0;
        }

        #score-cpu3 {
            grid-area: score-cpu3;
            align-self: end;
            justify-self: center;
            margin: 0 0 5px 0;
        }

        /* Ron Overlay CSS */
        #ron-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .ron-dialog {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid var(--gold);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            color: white;
            box-shadow: 0 0 20px var(--gold);
            min-width: 300px;
        }

        .ron-message {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--gold);
            font-weight: bold;
        }

        .ron-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
        }

        #btn-ron {
            font-size: 1.2rem;
            padding: 10px 30px;
            background: var(--gold);
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            color: #000;
        }

        #btn-pass {
            font-size: 1.2rem;
            padding: 10px 30px;
            background: #666;
            color: #ccc;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #btn-ron:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px var(--gold);
        }

        #btn-pass:hover {
            background: #888;
            color: white;
        }
    </style>
</head>

<body>
    <div id="game-container">
        <aside id="side-panel">
            <header class="info-bar">
                <div id="status-message">九九合わせへようこそ</div>
                <button id="start-btn">ゲーム開始</button>
            </header>
            <div id="settings-area"
                style="padding: 10px; color: var(--gold); border-bottom: 1px solid rgba(255,255,255,0.1);">
                <div style="margin-bottom: 5px;">
                    <label>NPC人数:
                        <select id="setting-players"
                            style="background: rgba(0,0,0,0.5); color: white; border: 1px solid var(--gold); border-radius: 4px;">
                            <option value="1">1人 (対面)</option>
                            <option value="2">2人 (左右)</option>
                            <option value="3" selected>3人 (全員)</option>
                        </select>
                    </label>
                </div>
                <div>
                    <label>強さ:
                        <select id="setting-level"
                            style="background: rgba(0,0,0,0.5); color: white; border: 1px solid var(--gold); border-radius: 4px;">
                            <option value="1">Lv1 (易)</option>
                            <option value="2" selected>Lv2 (普)</option>
                            <option value="3">Lv3 (難)</option>
                        </select>
                    </label>
                </div>
            </div>
            <div id="log" class="log-container"></div>
        </aside>
        <main id="game-board">
            <div id="round-info">1/5回戦</div>
            <!-- CPU 2 (North) -->
            <div class="hand-area horizontal north-hand" id="hand-cpu2"></div>
            <div class="discard-area horizontal north-discard" id="discard-cpu2"></div>
            <div class="score-tag" id="score-cpu2">0</div>

            <!-- CPU 1 (West) -->
            <div class="hand-area vertical west-hand" id="hand-cpu1"></div>
            <div class="discard-area vertical west-discard" id="discard-cpu1"></div>
            <div class="score-tag" id="score-cpu1">0</div>

            <!-- Center -->
            <div id="center-area">
                <div id="deck-container" style="text-align:center;">
                    <div id="deck-pile" class="card back"></div>
                    <div id="deck-count">山札: --</div>
                </div>
            </div>

            <!-- CPU 3 (East) -->
            <div class="hand-area vertical east-hand" id="hand-cpu3"></div>
            <div class="discard-area vertical east-discard" id="discard-cpu3"></div>
            <div class="score-tag" id="score-cpu3">0</div>

            <!-- Player (South) -->
            <div class="discard-area horizontal south-discard" id="discard-player"></div>
            <div class="score-tag" id="score-player">0</div>
            <div class="hand-area horizontal south-hand" id="player-hand"></div>
        </main>
        <div id="reveal-overlay">
            <div class="reveal-title" id="reveal-text">勝利！</div>
            <div class="reveal-cards" id="reveal-cards-area"></div>
            <button id="close-reveal">閉じる</button>
        </div>
        <div id="ron-overlay">
            <div class="ron-dialog">
                <div id="ron-message" class="ron-message">CPU1の捨て牌 10 でロンしますか？</div>
                <div class="ron-buttons">
                    <button id="btn-ron">ロン！</button>
                    <button id="btn-pass">パス</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        class Card {
            constructor(number) { this.number = number; this.dans = this.calcDans(number); }
            calcDans(n) {
                const dans = new Set();
                for (let i = 1; i <= 9; i++) { if (n % i === 0 && n / i >= 1 && n / i <= 9) dans.add(i); }
                return dans;
            }
        }
        class Player {
            constructor(name, id, isHuman = false) { this.name = name; this.id = id; this.isHuman = isHuman; this.hand = []; this.discards = []; this.score = 0; }
            checkTenpai() {
                if (this.hand.length < 4) return null;
                let common = new Set(this.hand[0].dans);
                for (let i = 1; i < 4; i++) common = new Set([...common].filter(x => this.hand[i].dans.has(x)));
                return common.size > 0 ? common : null;
            }
            checkAgari() {
                if (this.hand.length < 5) return null;
                let common = new Set(this.hand[0].dans);
                for (let i = 1; i < 5; i++) common = new Set([...common].filter(x => this.hand[i].dans.has(x)));
                return common.size > 0 ? Array.from(common) : null;
            }
            checkRon(discardedCard) {
                const tenpai = this.checkTenpai();
                if (!tenpai) return null;
                const match = [...tenpai].filter(d => discardedCard.dans.has(d));
                return match.length > 0 ? match : null;
            }
        }
        class GameEngine {
            constructor(playerCount = 3, difficulty = 2) {
                // Players: 0=Human. NPC slots: 1=West(L), 2=North(C), 3=East(R)
                // playerCount selection:
                // 1 -> Human vs North (CPU2)
                // 2 -> Human vs West (CPU1) vs East (CPU3)
                // 3 -> Human vs West, North, East (Full)

                this.players = [];
                this.players.push(new Player("あなた", "player", true));

                // Configurable logic
                if (playerCount == 1) {
                    this.players.push(new Player("CPU2", "cpu2")); // North
                } else if (playerCount == 2) {
                    this.players.push(new Player("CPU1", "cpu1")); // West
                    this.players.push(new Player("CPU3", "cpu3")); // East
                } else {
                    this.players.push(new Player("CPU1", "cpu1"));
                    this.players.push(new Player("CPU2", "cpu2"));
                    this.players.push(new Player("CPU3", "cpu3"));
                }

                this.difficulty = difficulty;
                this.deck = [];
            }
            initializeDeck() {
                this.deck = [];
                const seen = new Set();
                for (let i = 1; i <= 9; i++) for (let j = 1; j <= 9; j++) { const n = i * j; if (!seen.has(n)) { seen.add(n); this.deck.push(new Card(n)); } }
                for (let i = this.deck.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[this.deck[i], this.deck[j]] = [this.deck[j], this.deck[i]]; }
            }
            reset() { this.initializeDeck(); this.players.forEach(p => { p.hand = []; p.discards = []; }); }
            draw() { return this.deck.length > 0 ? this.deck.pop() : null; }
            cpuChooseDiscard(cpu) {
                // Lv1: Random
                if (this.difficulty == 1) {
                    return Math.floor(Math.random() * cpu.hand.length);
                }

                // Lv2/3: Heuristic (Basic)
                const danCount = {}; for (let d = 1; d <= 9; d++) danCount[d] = 0;
                cpu.hand.forEach(c => c.dans.forEach(d => danCount[d]++));
                let minScore = Infinity, discardIdx = 0;

                // Lv3: Avoid discarding risky cards (Simple implementation: prefer discarding smaller numbers or those with fewer factors if tied)
                // For now, Lv2 and Lv3 share the basic logic of keeping cards that overlap in dan
                // Add a small randomization or preference for Lv3 later if needed.

                cpu.hand.forEach((c, idx) => {
                    let score = 0;
                    c.dans.forEach(d => score += danCount[d]);

                    if (score < minScore) {
                        minScore = score;
                        discardIdx = idx;
                    }
                });
                return discardIdx;
            }
        }
        class GameUI {
            constructor() {
                this.engine = null;
                this.gameInProgress = false;
                this.winnerInfo = null;
                this.maxRounds = 5;
                this.currentRound = 0;
                this.initElements();
                this.attachEvents();
            }
            initElements() {
                this.logArea = document.getElementById('log'); this.startBtn = document.getElementById('start-btn');
                this.statusMsg = document.getElementById('status-message');
                this.deckCount = document.getElementById('deck-count'); this.revealOverlay = document.getElementById('reveal-overlay');
                this.revealText = document.getElementById('reveal-text'); this.revealCardsArea = document.getElementById('reveal-cards-area');
                this.closeRevealBtn = document.getElementById('close-reveal');
                this.roundDisplay = document.getElementById('round-info');
                this.scoreTags = {
                    'player': document.getElementById('score-player'),
                    'cpu1': document.getElementById('score-cpu1'),
                    'cpu2': document.getElementById('score-cpu2'),
                    'cpu3': document.getElementById('score-cpu3')
                };
            }
            attachEvents() { this.startBtn.addEventListener('click', () => this.handleStartButton()); this.closeRevealBtn.addEventListener('click', () => this.revealOverlay.style.display = 'none'); }
            appendLog(msg) { const div = document.createElement('div'); div.innerHTML = '> ' + msg; this.logArea.appendChild(div); this.logArea.scrollTop = this.logArea.scrollHeight; }
            updateInfo() {
                this.deckCount.textContent = '山札: ' + this.engine.deck.length + '枚';

                // Reset text for all potential tags first
                Object.values(this.scoreTags).forEach(tag => { if (tag) tag.style.display = 'none'; });

                this.engine.players.forEach(p => {
                    if (this.scoreTags[p.id]) {
                        this.scoreTags[p.id].textContent = 'Score: ' + p.score;
                        this.scoreTags[p.id].style.display = 'block';
                    }
                });

                if (this.currentRound > 0 && this.currentRound <= this.maxRounds) {
                    this.roundDisplay.textContent = `${this.currentRound}/${this.maxRounds}回戦`;
                } else if (this.currentRound > this.maxRounds) {
                    this.roundDisplay.textContent = "対局終了";
                    document.getElementById('settings-area').style.display = 'block'; // Show settings again
                }
            }
            createCardElement(card, isBack, isRotated, isMini) {
                const el = document.createElement('div');
                let rotClass = '';
                if (typeof isRotated === 'string') rotClass = ' ' + isRotated;
                else if (isRotated) rotClass = ' rotated';

                el.className = 'card' + (isBack ? ' back' : '') + (isMini ? ' mini' : '') + rotClass;
                el.textContent = isBack ? '' : card.number; return el;
            }
            createDiscardElement(card, isRotated) { const el = document.createElement('div'); el.className = 'discard-card' + (isRotated ? ' rotated' : ''); el.textContent = card.number; return el; }
            getHandAreaId(playerId) { return playerId === 'player' ? 'player-hand' : 'hand-' + playerId; }
            renderPlayer(p) {
                const handDiv = document.getElementById(this.getHandAreaId(p.id)); if (!handDiv) return;
                handDiv.innerHTML = '';

                // Determine rotation class for hand cards
                let rotateParam = false;
                if (p.id === 'cpu1') rotateParam = 'rotated'; // West (90deg)
                if (p.id === 'cpu3') rotateParam = 'rotated-east'; // East (-90deg)

                // For discards, we still use the generic 'rotated' flag (boolean) because discards are handled by size swap now, not transform
                const isRotatedDiscard = (p.id === 'cpu1' || p.id === 'cpu3');

                // ゲーム終了時は全員の手札を表にする
                const isBack = (!p.isHuman && this.gameInProgress);

                p.hand.forEach((card, i) => {
                    const el = this.createCardElement(card, isBack, rotateParam, !p.isHuman);
                    if (p.isHuman && this.gameInProgress && p.hand.length === 5) { el.onclick = () => this.playerDiscard(i); el.style.cursor = 'pointer'; }

                    // 勝者の手札ハイライト
                    if (this.winnerInfo && this.winnerInfo.player.id === p.id) {
                        el.classList.add('winner-card');
                    }
                    handDiv.appendChild(el);
                });

                const discardDiv = document.getElementById('discard-' + p.id);
                if (discardDiv) {
                    discardDiv.innerHTML = '';
                    p.discards.forEach(c => {
                        const el = this.createDiscardElement(c, isRotatedDiscard);
                        // ロン牌ハイライト
                        if (this.winnerInfo && this.winnerInfo.targetPlayer && this.winnerInfo.targetPlayer.id === p.id && this.winnerInfo.winningCard === c) {
                            el.classList.add('ron-card');
                        }
                        discardDiv.appendChild(el);
                    });
                }
            }
            renderAll() {
                this.engine.players.forEach(p => this.renderPlayer(p));
            }
            handleStartButton() {
                if (this.currentRound === 0 || this.currentRound > this.maxRounds) {
                    const pCount = parseInt(document.getElementById('setting-players').value);
                    const diff = parseInt(document.getElementById('setting-level').value);
                    this.engine = new GameEngine(pCount, diff);
                    this.currentRound = 1;
                    this.startGame();
                } else {
                    this.currentRound++;
                    this.startGame();
                }
            }
            startGame() {
                // engineは既に存在
                this.engine.reset(); this.logArea.innerHTML = ''; this.revealOverlay.style.display = 'none';
                document.getElementById('settings-area').style.display = 'none'; // Hide settings during game
                this.startBtn.disabled = true; this.startBtn.textContent = "対局中"; this.gameInProgress = true; this.winnerInfo = null;
                // Deal cards to actual players
                for (let i = 0; i < 4; i++) this.engine.players.forEach(p => { const c = this.engine.draw(); if (c) p.hand.push(c); });
                this.renderAll(); this.updateInfo();
                this.appendLog("=== " + this.currentRound + "回戦 開始 ===");
                setTimeout(() => this.playerTurn(), 500);
            }
            playerTurn() {
                if (!this.gameInProgress) return;
                const player = this.engine.players[0]; const c = this.engine.draw();
                if (!c) { this.endRound("山札切れ - 引き分け"); return; }
                player.hand.push(c); this.renderPlayer(player); this.updateInfo();
                this.appendLog('あなたは <b>' + c.number + '</b> を引きました');
                const agari = player.checkAgari(); if (agari) { this.win(player, agari, "ツモ"); return; }
                this.statusMsg.textContent = "捨てるカードを選択してください";
            }
            playerDiscard(idx) {
                if (!this.gameInProgress) return; const player = this.engine.players[0]; if (player.hand.length < 5) return;
                const discarded = player.hand.splice(idx, 1)[0]; player.discards.push(discarded);
                this.renderPlayer(player); this.appendLog('あなたは <b>' + discarded.number + '</b> を捨てました');
                for (let i = 1; i < this.engine.players.length; i++) { const cpu = this.engine.players[i]; const ron = cpu.checkRon(discarded); if (ron) { cpu.hand.push(discarded); this.win(cpu, ron, "ロン", discarded, player); return; } }
                this.processCpu(1);
            }
            showRonDialog(message, onRon, onPass) {
                const overlay = document.getElementById('ron-overlay');
                const msgEl = document.getElementById('ron-message');
                const btnRon = document.getElementById('btn-ron');
                const btnPass = document.getElementById('btn-pass');

                msgEl.textContent = message;
                overlay.style.display = 'flex';

                btnRon.onclick = () => { overlay.style.display = 'none'; onRon(); };
                btnPass.onclick = () => { overlay.style.display = 'none'; onPass(); };
            }

            processCpu(idx) {
                if (!this.gameInProgress) return; if (idx >= this.engine.players.length) { this.playerTurn(); return; }
                const cpu = this.engine.players[idx]; this.statusMsg.textContent = cpu.name + ' の思考中...';
                setTimeout(() => {
                    if (!this.gameInProgress) return; const c = this.engine.draw();
                    if (!c) { this.endRound("山札切れ - 引き分け"); return; }
                    cpu.hand.push(c); this.appendLog(cpu.name + ' がカードを引きました');
                    const agari = cpu.checkAgari(); if (agari) { this.win(cpu, agari, "ツモ"); return; }
                    const discardIdx = this.engine.cpuChooseDiscard(cpu); const discarded = cpu.hand.splice(discardIdx, 1)[0];
                    cpu.discards.push(discarded); this.renderPlayer(cpu); this.updateInfo();
                    this.appendLog(cpu.name + ' が <b>' + discarded.number + '</b> を捨てました');

                    const player = this.engine.players[0]; const playerRon = player.checkRon(discarded);
                    if (playerRon) {
                        this.showRonDialog(
                            cpu.name + 'の捨てた ' + discarded.number + ' でロンしますか？',
                            () => { player.hand.push(discarded); this.win(player, playerRon, "ロン", discarded, cpu); },
                            () => { this.processCpuContinue(idx, discarded); }
                        );
                        return;
                    }
                    this.processCpuContinue(idx, discarded);
                }, 600);
            }

            processCpuContinue(idx, discarded) {
                const currentCpu = this.engine.players[idx];
                for (let i = 1; i < this.engine.players.length; i++) {
                    if (i === idx) continue;
                    const otherCpu = this.engine.players[i];
                    const ron = otherCpu.checkRon(discarded);
                    if (ron) { otherCpu.hand.push(discarded); this.win(otherCpu, ron, "ロン", discarded, currentCpu); return; }
                }
                this.processCpu(idx + 1);
            }
            win(player, dans, type, winningCard = null, targetPlayer = null) {
                this.gameInProgress = false;
                this.winnerInfo = { player, type, winningCard, targetPlayer };
                this.renderAll(); // 全員の手札を公開・ハイライト

                const dansStr = Array.isArray(dans) ? dans.join(',') : [...dans].join(',');
                const handSum = player.hand.reduce((s, c) => s + c.number, 0);
                this.appendLog(' <b>' + player.name + '</b> が <b>' + type + '</b>！ (' + dansStr + 'の段) 得点: ' + handSum);
                player.score += handSum;
                this.updateInfo();

                this.revealText.textContent = player.name + ' の ' + type + '！ (' + dansStr + 'の段)';
                this.revealCardsArea.innerHTML = '';
                // 結果表示のみ
                const resultMsg = document.createElement('div');
                resultMsg.style.color = 'white';
                resultMsg.style.fontSize = '1.2rem';
                resultMsg.innerHTML = `役: ${dansStr}の段<br>今回の得点: ${handSum}<br>累計スコア: ${player.score}`;
                this.revealCardsArea.appendChild(resultMsg);

                this.revealOverlay.style.display = 'flex'; this.startBtn.disabled = false;

                if (this.currentRound < this.maxRounds) {
                    this.startBtn.textContent = "次の対局へ";
                } else {
                    this.showFinalResult();
                    this.startBtn.textContent = "最初から遊ぶ";
                    this.currentRound = 6;
                }
            }
            showFinalResult() {
                const winner = this.engine.players.reduce((prev, current) => (prev.score > current.score) ? prev : current);
                const finalResultDiv = document.createElement('div');
                finalResultDiv.style.marginTop = '20px';
                finalResultDiv.style.padding = '15px';
                finalResultDiv.style.background = 'rgba(212, 175, 55, 0.2)';
                finalResultDiv.style.borderRadius = '10px';
                finalResultDiv.style.border = '1px solid var(--gold)';
                finalResultDiv.style.textAlign = 'center';

                let html = `<h3>=== 全5回戦終了 ===</h3><div style="font-size:1.5rem; margin: 10px 0; color: var(--gold);">優勝: ${winner.name}</div><div>スコア: ${winner.score}</div><br><div>順位:</div>`;
                const sortedPlayers = [...this.engine.players].sort((a, b) => b.score - a.score);
                sortedPlayers.forEach((p, i) => {
                    html += `<div>${i + 1}位: ${p.name} (${p.score})</div>`;
                });
                finalResultDiv.innerHTML = html;
                this.revealCardsArea.appendChild(finalResultDiv);
            }
            endRound(msg) {
                this.gameInProgress = false; this.appendLog(msg); this.statusMsg.textContent = msg; this.startBtn.disabled = false;
                if (this.currentRound < this.maxRounds) {
                    this.startBtn.textContent = "次の対局へ";
                } else {
                    this.revealText.textContent = msg;
                    this.revealCardsArea.innerHTML = '';
                    this.showFinalResult();
                    this.revealOverlay.style.display = 'flex';
                    this.startBtn.textContent = "最初から遊ぶ";
                    this.currentRound = 6;
                }
            }
        }
        window.onload = () => { new GameUI(); };
    </script>
</body>

</html>